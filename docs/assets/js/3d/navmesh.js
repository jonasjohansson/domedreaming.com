import{GLTFLoader}from"three/addons/loaders/GLTFLoader.js";import{init as initRecastNavigation,NavMeshQuery,importNavMesh}from"@recast-navigation/core";import{threeToSoloNavMesh}from"@recast-navigation/three";import{scene,camera}from"./scene.js";import{CAMERA_HEIGHT,NAVMESH_SEARCH_BOX}from"./config.js";import{safeTraverse}from"./utils.js";import{setNavMeshQuery}from"./movement.js";import{modelLoaded,setModelLoaded}from"./camera.js";let recastInitialized=!1,navmesh=null,navmeshMeshes=[],navMeshQuery=null;export function getNavMeshQuery(){return navMeshQuery}async function initRecast(){if(!recastInitialized)try{await initRecastNavigation(),recastInitialized=!0,loadNavmesh()}catch(e){recastInitialized=!0}}async function loadNavmesh(){if(recastInitialized){try{const e=await fetch("assets/models/navmesh.bin");if(e.ok){const a=await e.arrayBuffer(),s=new Uint8Array(a),{navMesh:t}=importNavMesh(s);return navMeshQuery=new NavMeshQuery(t),setNavMeshQuery(navMeshQuery),void(modelLoaded&&verifyNavmeshAtStartPosition())}}catch(e){}loadNavmeshGLTF()}else await initRecast()}function loadNavmeshGLTF(){(new GLTFLoader).load("assets/models/navmesh.gltf",async e=>{if(navmesh=e.scene,navmesh.scale.setScalar(1),navmesh.visible=!1,safeTraverse(navmesh,e=>{e.isMesh&&(navmeshMeshes.push(e),e.updateMatrixWorld())}),scene.add(navmesh),navmeshMeshes.length>0&&recastInitialized){const{success:e,navMesh:a}=threeToSoloNavMesh(navmeshMeshes,{cs:.05,ch:.05,walkableRadius:.2});e&&(navMeshQuery=new NavMeshQuery(a),setNavMeshQuery(navMeshQuery))}},void 0,e=>{})}export function verifyNavmeshAtStartPosition(){if(!navMeshQuery||!modelLoaded)return;const e={x:camera.position.x,y:camera.position.y-CAMERA_HEIGHT,z:camera.position.z},a=navMeshQuery.findClosestPoint(e,{halfExtents:NAVMESH_SEARCH_BOX});a.success&&(camera.position.y=a.point.y+CAMERA_HEIGHT)}export function initNavmesh(){initRecast().catch(console.error)}